\chapter{使用make更新静态库文件}
静态库文件也称为“文档文件”，它是一些.o文件的集合。在Linux（Unix）中使用工具
“ar”对它进行维护管理。它所包含的成员（member）是若干.o文件。

\section{库成员作为目标}
一个静态库通常由多个.o文件组成。这些成员（.o文件）可独立的被作为一个规则的目
标，库成员作为目标时需要按照如下的格式来书写：

\begin{Verbatim}[]
ARCHIVE(MEMBER)
\end{Verbatim}

注意，这种书写方式只能出现在规则的目标和依赖，不能出现在规则的命令行中！因
为，绝大多数命令不能支持这种语法，命令不能直接对库的成员进行操作。这种表达式
在规则的目标或者依赖中，它表示库“ARCHIVE”的成员“MEMBER”。含有这种表达式的规则
的命令行只能是“ar”命令或者其它可以对库成员进行操作的命令。例如：下边这个规则
用于创建库“foolib”，并将“hack.o”成员加入到库：
\begin{Verbatim}[]
foolib(hack.o) : hack.o
    ar cr foolib hack.o
\end{Verbatim}
\noindent 实际上，这个规则实现了对库的所有成员进行了更新，其过程使用了隐含规
则（创建需要的.o文件）。另外需要注意工具“ar”的用法（可参考ar的man手册）。

如果在规则中需要同时指定库的多个成员，可以将多个成员罗列在括号内，例如：
\begin{Verbatim}[]
foolib(hack.o kludge.o)
\end{Verbatim}
\noindent 它就等价于：
\begin{Verbatim}[]
foolib(hack.o) foolib(kludge.o)
\end{Verbatim}
在描述库的多个成员时也可以使用shell通配符。例如：“foolib(*.o)”，它代表库文件
“foolib”的所有.o成员。

\section{静态库的更新}
上一节已经讲述了规则中形如“A(M)”目标的含义，它代表静态库“A”的成员“M”。make为
这样的一个目标搜索隐含规则时，可重建“(M)”的隐含规则，同样也被认为是可重建
“A(M)”这个目标的隐含规则。

这就出现了一个特殊的模式规则，它的目标模式是“(\%)”。这个特殊的规则被用来更新
目标“A(M)”，规则将文件“M”拷贝到库“A”中，如果之前在静态库文件“A”不存，则首先创
建这个库文件。例如：目标为“foo.a(bar.o)”的规则，执行时将完成：首先使用隐含规
则生成其成员“bar.o”，之后将“bar.o”加入到库“foo.a”中。那么“bar.o”就作为库文件
“foo.a”的一个成员（当然如果“foo.a”不存在，就会被创建。这个特殊规则的命令行一
般都是“ar”命令）。

这个特殊的规则可以和其它隐含规则一起构成一个隐含规则链。因此我们可以直接在命
令行中执行“make ‘foo.a(bar.o)’”（注意“foo.a(bar.o)”作为命令行选项，需要使用引
号，否则shell会将“(”作为特殊字符处理），只要当前目录下存在“bar.c”这个文件，就
会执行如下命令：
\begin{Verbatim}[]
cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
\end{Verbatim}

我们可以看到文件“bar.o”是被作为中间过程文件来处理的。需要说明的是，包含上述命
令的规则，在规则的命令行中使用自动化变量“\$\%”来代表库成员“bar.o”。

在一个静态库（文档文件）中，其所有的成员名是不包含目录描述的。就是说对于静态
库，当使用“nm”命令查看其成员时，能够获得的信息只是静态库所包含的成员名字（一
系列.o文件，文件名中并没有包含目录）。但我们在Makefile中，采用“A(M)”格式的目
标，书写建立（重建或者更新）静态库的规则时，可以指定为库它的成员指定路径。就
是说在描述它的成员时，可以使用包含路径的文件名。例如一个规则的目标可以这样书
写“foo.a(dir/file.o)”，在这个规则被执行时可能会执行如下的命令：

\begin{Verbatim}[]
ar r foo.a dir/file.o
\end{Verbatim}

和上边的例子类似，它将指定目录下的.o文件加入到库中，此文件（“dir/file.o”）被
作为静态库的一个成员。对于类似这样的目标，重建它的隐含规则的命令行中可能就需
要使用自动化变量“\%D”和“\%F”。

\subsection{更新静态库的符号索引表}
本小节的内容相对简单。前边提到过，静态库文件需要使用“ar”来创建和维护。当给静
态库增建一个成员时（加入一个.o文件到静态库中），“ar”可直接将需要增加的.o文件
简单的追加到静态库的末尾。之后当我们使用这个库进行连接生成可执行文件时，链接
程序“ld”却提示错误，这可能是：主程序使用了之前加入到库中的.o文件中定义的一个
函数或者全局变量，但连接程序无法找到这个函数或者变量。

这个问题的原因是：之前我们将编译完成的.o文件直接加入到了库的末尾，却并没有更
新库的有效符号表。连接程序进行连接时，在静态库的符号索引表中无法定位刚才加入
的.o文件中定义的函数或者变量。这就需要在完成库成员追加以后让加入的所有.o文件
中定义的函数（变量）有效，完成这个工作需要使用另外一个工具“ranlib”来对静态库
的符号索引表进行更新。

我们所使用到的静态库（文档文件）中，存在这样一个特殊的成员，它的名字是
“\_{}\_.SYMDEF”。它包含了静态库中所有成员所定义的有效符号（函数名、变量名）。
因此，当为库增加了一个成员时，相应的就需要更新成员“\_{}\_.SYMDEF”，否则所增加
的成员中定义的所有的符号将无法被连接程序定位。完成更新的命令是：

\begin{Verbatim}[]
ranlib ARCHIVEFILE
\end{Verbatim}

通常在Makefile中我们可以这样来实现：
\begin{Verbatim}[]
libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
    ranlib libfoo.a
\end{Verbatim}
\noindent 它所实现的是在更新静态库成员“x.o”和“y.o”之后，对静态库的成员
“\_\_.SYMDEF”进行更新（更新库的符号索引表）。

如果我们使用GNU ar工具来维护、管理静态库，我们就不需要考虑这一步。GNU ar本身
已经提供了在更新库的同时更新符号索引表的功能（这是默认行为，也可以通过命令行
选项控制ar的具体行为。可参考 GNU ar工具的man手册）。

\section{make静态库的注意事项}

在make静态库（文档文件）时，特别需要注意：make的并行执行（执行make时使用“-j”
选项）给更新静态库带来的影响。因为在同一时刻，当同时使用多个“ar”命令来操作相
同的静态库时，将会静损坏态库，甚至导致此静态库不可用。

可能在后期的make版本中，会提供一种在并行执行时防止同时多个“ar”命令对同一静态
库的操作的机制。但是就目前的版本来说，这个问题是存在的。因此要求我们在书写
Makefile时，加入控制策略来避免make并发执行时多个“ar”命令同时操作同一个静态库
文件。或者放弃使用make的并发执行功能。

\section{静态库的后缀规则}
静态库的后缀规则属于后缀规则的特殊应用，后缀规则在目前版本的GNU make中已经被
模式规则替代。但目前版本make同样支持旧风格的后缀规则，主要是为了兼容老版本的
make。对于静态库的重建也可以使用后缀规则。目标后缀需要是“.a”（在Linux（Unix）
中、静态库的后缀为.a）。例如这样一个后缀规则：

\begin{Verbatim}[]
.c.a:
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    $(AR) r $@ $*.o
    $(RM) $*.o
\end{Verbatim}

它相当于模式规则：

\begin{Verbatim}[]
(%.o): %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    $(AR) r $@ $*.o
    $(RM) $*.o
\end{Verbatim}

对于老风格的后缀规则，它的目标是“.a.c”，当转换为模式规则时。后缀规则中的“.a”
被作为模式规则的目标文件后缀（目标文件就是N.a）；“.c”被作为了模式规则依赖文件
的后缀（依赖文件就是N.c）。

存在这样一种情况：可能一个不是静态库的文件使用了后缀.a。那么make也会按照正常
的方式静态库的后缀规则转换成为一个模式规则。因此对于一个双后缀规则的目标
“.x.a”，经过make转换后会产生两个模式规则：“(\%.o): \%.x” 和“\%.a: \%.x”。具体
的转换过程可参考 后缀规则 一节。
