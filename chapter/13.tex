\chapter{和其它版本的兼容}
GNU make存在一些和其它版本make不兼容的功能，其它版本make具有的部分功能，在GNU make中也没有实现。POSIX.2 标准 （IEEE Standard 1003.2-1992）没有规定以下的这些特点需要在make中实现。

\begin{dinglist}{226}
\itemsep=4pt

\item 形如“FILE((ENTRY))”的目标代表静态库文件“FILE”的一个成员。它的成员不是用
    文件名，而是一个定义了连接符号“ENTRY”的.o文件。GNU make没有支持它的原因
    是：书写这样的规则要求书写者对静态库内部符号索引表熟悉。GNU make对静态库
    成员的更新可参考 第十一章。

\item 以字符“~” 结尾的后缀在System V make的后缀规则中有特别的含义；它指的是对
    应目标文件的依赖文件是没有“~”的SCCS 文件。例如，System V的后缀规则“.c~.o”
    含义是：“N.o”是从SCCS文件“s.N.c”中提取的。为了完全覆盖，可能需要一系列的
    这样的规则。GNU make对它的处理是：使用两个模式规则从SCCS文件抽取一个文
    件，这两个模式规则形成一个隐含规则链。可参考 10.4 隐含规则链 一节。

\item 在System V 和 4.3 BSD make中，通过“VPATH”指定的目录搜寻（参考 4.5 目录
    搜索 一节）的文件，对应的文件名需要经过make改变后才加入对应规则到命令行
    中。GNU make使用自动环变量来实现这一功能。

\item 在一些Unix的make中，自动化变量“\$*”（参考 10.5.3 自动化变量 一节）作为
    规
    则的依赖时，具有奇怪的特征：它会被扩展为该规则的目标全名。它和GNU make中
    “\$*”的含义完全不同。

\item  在一些Unix的make中。会为所有目标搜索隐含规则，不仅仅对那些没有命令的目
    标。就是说如果我们的规则时这样的话：

\begin{Verbatim}[]
foo.o:
    cc -c foo.c
\end{Verbatim}

这种版本的make就会认为目标“foo.o”的依赖文件是“foo.c”。我们认为make的这种处理
方法容易导致混乱。因为Makefile已经对目标有明确的定义，而在为目标搜索隐含规则
是不合逻辑的。因此GNU make没有支持这种方式的规则处理。


\item GNU make不包含任何编译以及预处理EFL程序的内嵌隐含规则。如果其它那种版本
    的make已经实现了这个特性，我们会很乐意地把它加入到GNU make支持的特性中。

\item 在 SVR4版本的make中，一个没有命令的后缀规则被作为一个空命令规则来处理。
    例如：

\begin{Verbatim}[]
.c.a:
\end{Verbatim}

这个规则将覆盖内嵌的目标为“.c.a”的规则。GNU make对这个规则的行为是为目标.a添
加一个依赖类型.c。上述的行为在GNU make中的实现是：

\begin{Verbatim}[]
.c.a: ;
\end{Verbatim}

\item  一些版本的make 在调用shell时使用“-e”参数告诉shell，在除执行“make -k”
    时，一旦命令行执行失败（返回状态非0）就立即退出。我们认为对于不同的命令的
    执行结果要视情况来处理。因此GNU make的没有支持这种方式。

\end{dinglist}
